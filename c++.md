## C++ 基础

+ **static关键字：**

  + 全局静态变量：位于静态储存区，自动初始化为0，作用域从定义处到文件结尾，在其他文件不可见
  + 全局变量：作用域是整个工程，在另一个文件中，通过extern的声明使用

  + 局部静态变量： 位于静态储存区，当变量离开作用域后，仍然留在内存中，被函数再次调用值不变
  + 静态函数：函数的定义和声明默认都是extern，静态函数只能在当前文件中使用
  + 类的静态成员变量：不占用类的大小，属于整个类所有，所有对象共享类的静态成员变量
  + 类的静态函数：属于整个类所有，只能访问静态成员变量和静态成员函数
+ **C++和C的区别**
  + C++ 面向对象，C 面向过程
  + C++ 封装，继承，多态
+ **C++中四种cast转换**
  + const_cast：将const遍历转为非const
  + static_case：用于隐式转换，用于向上转化，向下转化能成功但不安全
  + dynamic_cast：用于动态类型转换，只能用于含有虚函数的类
  + reinterpret_cast：强制转换，少用 
  + C的强制转换不能够进行错误检查，容易出错
+ **指针与引用的区别**
  
  + 指针有自己的一块空间，引用只是一个别名
  
  + 指针大小是4/8，引用大小是被引用对象的大小
  + 指针可以为nullptr，引用必须被初始化且不能重新引用其他
  + 可以用const/多级指针，但不可以有const引用
  + 指针自增是地址，引用自增是值
+ **C++中的四种智能指针：shared_ptr, unique_ptr, weak_ptr, auto_ptr**

  + auto_ptr: 采用所有权模式，存在潜在内存奔溃问题
  + unique_ptr: 替代auto_ptr,，会提前报错内存问题
    + std::move / ptest2 = std::move(ptest) 左值变为右值引用
    + 左值是可以取地址的，右值是不可以取地址的
    + 左值引用要求右边的值必须能够取地址
    + 右值引用 int && var = 10；
  + shared_ptr: 多个智能指针可以指向相同对象
    + 相互引用，会使引用计数失效
  + weak_ptr: 不控制对象生命周期的智能指针，可以解决shared的死锁问题

+ **虚函数与析构函数**

  + 父类的析构函数设置为虚函数，保证释放基类指针时可以释放子类的空间
  + 默认析构函数不是虚函数，因为虚函数需要额外的虚函数表和虚表指针，占用额外内存
  + 类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数
  + 静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定
  + 重载overload：参数不同 / 重写override：在子类中重新定义了虚函数
  + 多态polymorphism：继承+重写+父类引用指向子类对象
  + 没有virtual则成为静态多态，动态多态 virtual int area() = 0; 纯虚函数不能被实例化，只能被继承
  + struct也可以继承，区别在于struct继承默认是public，而class默认是private且可以定义模板类形参

+ **函数指针**

  + 函数指针是指向函数的指针变量
  + 指针变量指向一个具体的函数，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址

+ **New 和 malloc**

  + C++内存布局：堆，栈，自由储存区，全局/静态储存区，常量储存区

  + new从自由储存区分配内存，malloc从堆分配内存

  + new返回的类型与对象匹配，malloc返回void*

  + new内存分配失败会抛出异常，malloc则返回NULL

  + new不需要指定内存块大学，malloc需要显示地指出

  + new
  
    + 分配一块原始的足够大的空间
  + 运行构造函数来建立对象，并传入初值
    + 返回指向该对象的指针

  + delete
  
  + 调用对象的析构函数
    + 调用delete来释放内存空间
+ 对数组的处理 new[] (对于class) 对应 delete[]
  + new/delete实现可以基于malloc，而malloc实现不可以调用new
+ new/delete可以被重载，malloc/free不可以被重载
  + malloc/calloc分配之后，可以用realloc来重新分配实现扩充

+ **extern “C”**

  + C++调用C函数需要extern C，因为C语言没有函数重载。

+ **函数栈空间最大值**
  + 默认是1M，可以调整

+ **STL迭代器**

  + Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果
  + 迭代器不是指针，是类模板，表现的像指针

  + 对于序列容器vector,deque来说，使用erase(iterator)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器

  + map底层是红黑树，unordered map底层是哈希表

+ **C++源文件从文本到可执行文件**

  + 预编译阶段：gcc -E 对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件
  + 编译阶段.s ：gcc -S 将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件
  + 汇编阶段.o ：gcc -c /as 将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件
  + 链接阶段.exe ：gcc -o /ld 将多个目标文件及所需要的库连接成最终的可执行目标文件

  + include "" <> 双引号会查找当前头文件目录

+ **C++内存管理**
  + 在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。
  + 代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。
  + 数据段：存储程序中已初始化的全局变量和静态变量
  + bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。
  + 堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。
  + 映射区:存储动态链接库以及调用mmap函数进行的文件映射
  + 栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值

+ **C++ 11**

  + auto 自动推导类型
  + nullptr 转化成任意其他指针类型
  + std::shared_ptr、std::weak_ptr 新增的智能指针
  + 初始化列表 使用初始化列表来对类进行初始化

  + 右值引用 实现移动语义和完美转发
  + atomic原子操作用于多线程资源互斥操作
  + lambda表达式 匿名函数
  + 等